// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: job.sql

package sql

import (
	"context"
	"strings"
	"time"
)

const createJob = `-- name: CreateJob :exec
INSERT INTO jobs (JID, Type, GPUEnabled, Log, Details, PID, Cmdline, StartTime, WorkingDir, Status, IsRunning, HostID, UIDs, GIDs, Groups)
VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
`

type CreateJobParams struct {
	Jid        string
	Type       string
	Gpuenabled int64
	Log        string
	Details    []byte
	Pid        int64
	Cmdline    string
	Starttime  time.Time
	Workingdir string
	Status     string
	Isrunning  int64
	Hostid     string
	Uids       string
	Gids       string
	Groups     string
}

func (q *Queries) CreateJob(ctx context.Context, arg CreateJobParams) error {
	_, err := q.db.ExecContext(ctx, createJob,
		arg.Jid,
		arg.Type,
		arg.Gpuenabled,
		arg.Log,
		arg.Details,
		arg.Pid,
		arg.Cmdline,
		arg.Starttime,
		arg.Workingdir,
		arg.Status,
		arg.Isrunning,
		arg.Hostid,
		arg.Uids,
		arg.Gids,
		arg.Groups,
	)
	return err
}

const deleteJob = `-- name: DeleteJob :exec
DELETE FROM jobs WHERE JID = ?
`

func (q *Queries) DeleteJob(ctx context.Context, jid string) error {
	_, err := q.db.ExecContext(ctx, deleteJob, jid)
	return err
}

const listJobs = `-- name: ListJobs :many
SELECT jobs.jid, jobs.type, jobs.gpuenabled, jobs.log, jobs.details, jobs.pid, jobs.cmdline, jobs.starttime, jobs.workingdir, jobs.status, jobs.isrunning, jobs.hostid, jobs.uids, jobs.gids, jobs."groups", hosts.id, hosts.mac, hosts.hostname, hosts.os, hosts.platform, hosts.kernelversion, hosts.kernelarch, hosts.cpuphysicalid, hosts.cpuvendorid, hosts.cpufamily, hosts.cpucount, hosts.memtotal
FROM jobs
JOIN hosts ON hosts.ID = jobs.HostID
`

type ListJobsRow struct {
	Job  Job
	Host Host
}

func (q *Queries) ListJobs(ctx context.Context) ([]ListJobsRow, error) {
	rows, err := q.db.QueryContext(ctx, listJobs)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListJobsRow
	for rows.Next() {
		var i ListJobsRow
		if err := rows.Scan(
			&i.Job.Jid,
			&i.Job.Type,
			&i.Job.Gpuenabled,
			&i.Job.Log,
			&i.Job.Details,
			&i.Job.Pid,
			&i.Job.Cmdline,
			&i.Job.Starttime,
			&i.Job.Workingdir,
			&i.Job.Status,
			&i.Job.Isrunning,
			&i.Job.Hostid,
			&i.Job.Uids,
			&i.Job.Gids,
			&i.Job.Groups,
			&i.Host.ID,
			&i.Host.Mac,
			&i.Host.Hostname,
			&i.Host.Os,
			&i.Host.Platform,
			&i.Host.Kernelversion,
			&i.Host.Kernelarch,
			&i.Host.Cpuphysicalid,
			&i.Host.Cpuvendorid,
			&i.Host.Cpufamily,
			&i.Host.Cpucount,
			&i.Host.Memtotal,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listJobsByHostIDs = `-- name: ListJobsByHostIDs :many
SELECT jobs.jid, jobs.type, jobs.gpuenabled, jobs.log, jobs.details, jobs.pid, jobs.cmdline, jobs.starttime, jobs.workingdir, jobs.status, jobs.isrunning, jobs.hostid, jobs.uids, jobs.gids, jobs."groups", hosts.id, hosts.mac, hosts.hostname, hosts.os, hosts.platform, hosts.kernelversion, hosts.kernelarch, hosts.cpuphysicalid, hosts.cpuvendorid, hosts.cpufamily, hosts.cpucount, hosts.memtotal
FROM jobs
JOIN hosts ON hosts.ID = jobs.HostID
WHERE jobs.HostID IN (/*SLICE:host_ids*/?)
`

type ListJobsByHostIDsRow struct {
	Job  Job
	Host Host
}

func (q *Queries) ListJobsByHostIDs(ctx context.Context, hostIds []string) ([]ListJobsByHostIDsRow, error) {
	query := listJobsByHostIDs
	var queryParams []interface{}
	if len(hostIds) > 0 {
		for _, v := range hostIds {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:host_ids*/?", strings.Repeat(",?", len(hostIds))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:host_ids*/?", "NULL", 1)
	}
	rows, err := q.db.QueryContext(ctx, query, queryParams...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListJobsByHostIDsRow
	for rows.Next() {
		var i ListJobsByHostIDsRow
		if err := rows.Scan(
			&i.Job.Jid,
			&i.Job.Type,
			&i.Job.Gpuenabled,
			&i.Job.Log,
			&i.Job.Details,
			&i.Job.Pid,
			&i.Job.Cmdline,
			&i.Job.Starttime,
			&i.Job.Workingdir,
			&i.Job.Status,
			&i.Job.Isrunning,
			&i.Job.Hostid,
			&i.Job.Uids,
			&i.Job.Gids,
			&i.Job.Groups,
			&i.Host.ID,
			&i.Host.Mac,
			&i.Host.Hostname,
			&i.Host.Os,
			&i.Host.Platform,
			&i.Host.Kernelversion,
			&i.Host.Kernelarch,
			&i.Host.Cpuphysicalid,
			&i.Host.Cpuvendorid,
			&i.Host.Cpufamily,
			&i.Host.Cpucount,
			&i.Host.Memtotal,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listJobsByIDs = `-- name: ListJobsByIDs :many
SELECT jobs.jid, jobs.type, jobs.gpuenabled, jobs.log, jobs.details, jobs.pid, jobs.cmdline, jobs.starttime, jobs.workingdir, jobs.status, jobs.isrunning, jobs.hostid, jobs.uids, jobs.gids, jobs."groups", hosts.id, hosts.mac, hosts.hostname, hosts.os, hosts.platform, hosts.kernelversion, hosts.kernelarch, hosts.cpuphysicalid, hosts.cpuvendorid, hosts.cpufamily, hosts.cpucount, hosts.memtotal
FROM jobs
JOIN hosts ON hosts.ID = jobs.HostID
WHERE jobs.JID IN (/*SLICE:ids*/?)
`

type ListJobsByIDsRow struct {
	Job  Job
	Host Host
}

func (q *Queries) ListJobsByIDs(ctx context.Context, ids []string) ([]ListJobsByIDsRow, error) {
	query := listJobsByIDs
	var queryParams []interface{}
	if len(ids) > 0 {
		for _, v := range ids {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:ids*/?", strings.Repeat(",?", len(ids))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:ids*/?", "NULL", 1)
	}
	rows, err := q.db.QueryContext(ctx, query, queryParams...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListJobsByIDsRow
	for rows.Next() {
		var i ListJobsByIDsRow
		if err := rows.Scan(
			&i.Job.Jid,
			&i.Job.Type,
			&i.Job.Gpuenabled,
			&i.Job.Log,
			&i.Job.Details,
			&i.Job.Pid,
			&i.Job.Cmdline,
			&i.Job.Starttime,
			&i.Job.Workingdir,
			&i.Job.Status,
			&i.Job.Isrunning,
			&i.Job.Hostid,
			&i.Job.Uids,
			&i.Job.Gids,
			&i.Job.Groups,
			&i.Host.ID,
			&i.Host.Mac,
			&i.Host.Hostname,
			&i.Host.Os,
			&i.Host.Platform,
			&i.Host.Kernelversion,
			&i.Host.Kernelarch,
			&i.Host.Cpuphysicalid,
			&i.Host.Cpuvendorid,
			&i.Host.Cpufamily,
			&i.Host.Cpucount,
			&i.Host.Memtotal,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateJob = `-- name: UpdateJob :exec
UPDATE jobs SET
    Type = ?,
    GPUEnabled = ?,
    Log = ?,
    Details = ?,
    PID = ?,
    Cmdline = ?,
    StartTime = ?,
    WorkingDir = ?,
    Status = ?,
    IsRunning = ?,
    HostID = ?,
    UIDs = ?,
    GIDs = ?,
    Groups = ?
WHERE JID = ?
`

type UpdateJobParams struct {
	Type       string
	Gpuenabled int64
	Log        string
	Details    []byte
	Pid        int64
	Cmdline    string
	Starttime  time.Time
	Workingdir string
	Status     string
	Isrunning  int64
	Hostid     string
	Uids       string
	Gids       string
	Groups     string
	Jid        string
}

func (q *Queries) UpdateJob(ctx context.Context, arg UpdateJobParams) error {
	_, err := q.db.ExecContext(ctx, updateJob,
		arg.Type,
		arg.Gpuenabled,
		arg.Log,
		arg.Details,
		arg.Pid,
		arg.Cmdline,
		arg.Starttime,
		arg.Workingdir,
		arg.Status,
		arg.Isrunning,
		arg.Hostid,
		arg.Uids,
		arg.Gids,
		arg.Groups,
		arg.Jid,
	)
	return err
}
