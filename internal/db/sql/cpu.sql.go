// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: cpu.sql

package sql

import (
	"context"
	"strings"
)

const createCPU = `-- name: CreateCPU :exec
INSERT INTO cpus (PhysicalID, VendorID, Family, Count, MemTotal)
VALUES (?, ?, ?, ?, ?)
`

type CreateCPUParams struct {
	Physicalid string
	Vendorid   string
	Family     string
	Count      int64
	Memtotal   int64
}

func (q *Queries) CreateCPU(ctx context.Context, arg CreateCPUParams) error {
	_, err := q.db.ExecContext(ctx, createCPU,
		arg.Physicalid,
		arg.Vendorid,
		arg.Family,
		arg.Count,
		arg.Memtotal,
	)
	return err
}

const deleteCPU = `-- name: DeleteCPU :exec
DELETE FROM cpus WHERE PhysicalID = ?
`

func (q *Queries) DeleteCPU(ctx context.Context, physicalid string) error {
	_, err := q.db.ExecContext(ctx, deleteCPU, physicalid)
	return err
}

const listCPUs = `-- name: ListCPUs :many
SELECT physicalid, vendorid, family, count, memtotal FROM cpus
`

func (q *Queries) ListCPUs(ctx context.Context) ([]Cpu, error) {
	rows, err := q.db.QueryContext(ctx, listCPUs)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Cpu
	for rows.Next() {
		var i Cpu
		if err := rows.Scan(
			&i.Physicalid,
			&i.Vendorid,
			&i.Family,
			&i.Count,
			&i.Memtotal,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listCPUsByIDs = `-- name: ListCPUsByIDs :many
SELECT physicalid, vendorid, family, count, memtotal FROM cpus WHERE PhysicalID in (/*SLICE:ids*/?)
`

func (q *Queries) ListCPUsByIDs(ctx context.Context, ids []string) ([]Cpu, error) {
	query := listCPUsByIDs
	var queryParams []interface{}
	if len(ids) > 0 {
		for _, v := range ids {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:ids*/?", strings.Repeat(",?", len(ids))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:ids*/?", "NULL", 1)
	}
	rows, err := q.db.QueryContext(ctx, query, queryParams...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Cpu
	for rows.Next() {
		var i Cpu
		if err := rows.Scan(
			&i.Physicalid,
			&i.Vendorid,
			&i.Family,
			&i.Count,
			&i.Memtotal,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateCPU = `-- name: UpdateCPU :exec
UPDATE cpus SET
    VendorID = ?,
    Family = ?,
    Count = ?,
    MemTotal = ?
WHERE PhysicalID = ?
`

type UpdateCPUParams struct {
	Vendorid   string
	Family     string
	Count      int64
	Memtotal   int64
	Physicalid string
}

func (q *Queries) UpdateCPU(ctx context.Context, arg UpdateCPUParams) error {
	_, err := q.db.ExecContext(ctx, updateCPU,
		arg.Vendorid,
		arg.Family,
		arg.Count,
		arg.Memtotal,
		arg.Physicalid,
	)
	return err
}
